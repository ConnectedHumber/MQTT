#------------------------------------------
#--- Authors: Robin Harris/Brian Norman
#--- Date: 19th february 2019
#--- Version: 2.13
#--- Python Ver: 3.6
#
# This version receives MQTT messages from a broker.
# The keys MUST include a "dev" which is the unique device identifer.  Other valid keys:
# "timestamp", "temp", "humidity", "pressure", "PM10", "PM25"
# "timestamp" is used for a device generated date and time
# if it is not present a date and time will be generated by this program
#
# Original code changed to work with new foreign keys between the reading_values and reading_value_types tables
#
# Incoming data is stored to a MariaDb database on Soekris
#
# Changes:
# 2.10  first release for new database structure
# 2.11  removed timestamp from allowed_json_value_keys
# 2.12  added global version variable to startup log message 
#		added on_message counter
# 2.13	added code to pick up GPS lat and long co-ordinates if sent
#		added checks to ensure the MQTT broker has actually connected before continuing
#		added checks for malformed JSON
#		moved config settings into settings.py
#----------------------------------------------------------------------

VERSION="2.13"

import paho.mqtt.client as paho
import datetime
import mysql.connector
import time
import json
import copy
import logging
import sys

from settings import *

mydb=None		# global variable required
message_number=0	# for trackinmg log messages for each on_message
brokerConnected=False

# log settings
logFile="chDataLoad_JSON.log"
logging.basicConfig(filename=logFile,format='%(asctime)s %(message)s', level=logging.DEBUG)


# JSON keys we process
allowed_json_value_keys="temp,temperature,pressure,humidity,PM10,PM25"

# GPS position keys
LATITUDE="lat"
LONGITUDE="long"

# reading_value_types_id values (fixed values, does not warrant SQL)
types_id={}
types_id["humidity"]=1
types_id["PM10"]=2
types_id["PM25"]=3
types_id["pressure"]=4
types_id["temperature"]=5
types_id["temp"]=5			# an alias for temperature


print("Starting to run chDataLoad_JSON.py")		# useful for when the task is first started
logging.info("#############################")	# make it easy to see the restart
logging.info("chDataLoad_JSON Version %s begins",VERSION)

def dbUpdate(sql, vals):
	global mydb

	logging.info("dbUpdate(): SQL=%s vals=%s",sql,str(vals))
	last_insert_id=None
	try:
		# check if the database connection is still open and if not reconnect
		mydb.ping(reconnect=True, attempts=5,delay=1)

		# execute SQL to insert a row
		mycursor=mydb.cursor()
		mycursor.execute(sql, vals) # add sql to return last_insert_id()
		# commit the change
		mydb.commit()
		mycursor.execute("select last_insert_id()")
		last_insert_id=mycursor.fetchone()[0]	# return last_insert_id
		return last_insert_id
	except Exception as e:
		logging.exception("dbUpdate(): failed to insert record.")
		return last_insert_id

def on_connect(mqttc, obj, flags, rc):
	global brokerConnected

	if rc==0:
		brokerConnected=True
		logging.info("on_connect(): callback ok, subscribing to Topic: %s",mqttTopic)
		mqttc.subscribe(mqttTopic, 0)
	else:
		brokerConnected=False
		logging.info("on_connect(): callback error rc=%s",str(rc))


def process_msg(msg_num,msg):
	global mydb

	# called from on-message to localise variables
	logging.info("process_msg(%s): payload=%s",msg_num,msg.payload)

	payloadJson = json.loads(msg.payload.decode("utf-8"))
	mycursor=mydb.cursor()	# BNN use local variable

	logging.info("process_msg(%s): JSON read ok",msg_num)

	# set all variables to None
	device_id = device_name = temperature = pressure = humidity = pm10 = pm25 = dateTimeString = None

	recordedOnString = recordedOnObject = None
	receivedOnString = receivedOnObject = None
	readings_id = None

	# first get the device_id from the device_name by looking it up in the database

	try:
		device_name = payloadJson['dev']
		# SQL SELECT to find device_id
		sql = "SELECT device_id FROM devices WHERE device_name = %s"
		vals = (device_name,)

		# check if the database connection is still open and if not reconnect
		mydb.ping(reconnect=True, attempts=5, delay=1)

		# execute SQL to return one record or None
		mycursor.execute(sql, vals)
		rec = mycursor.fetchone()

		# don't go on if the device_name is not known
		if rec is None:
			logging.error("process_msg(%s): device_id not found  name=%s. Aborted data insertion.",msg_num,device_name)
			return
		
		# get the device_id from the record
		device_id=rec[0]	# rec is a tuple
		logging.info("process_msg(%s): device_id=%s",msg_num,str(device_id))

	except mysql.connector.InterfaceError:
		logging.exception("process_msg(%s): Unable to connect to database. Insertion skipped",msg_num);
		return

	# Next decode the incoming message and set up the variables to be inserted
	# construct a dictionary of parameters and values
	parameters = copy.copy(payloadJson)
  
	if 'timestamp' in payloadJson:
		
		dateTimeString = payloadJson['timestamp']
		logging.info("process_msg(%s): JSON includes a timestamp %s",msg_num,dateTimeString)

		# create a Python datetime object from the dateTimeString
		recordedOnObject = datetime.datetime.strptime(dateTimeString, '%a %b %d %Y %H:%M:%S %Z%z')
		# recordedONString is a string in the required database format
		recordedOnString = recordedOnObject.strftime('%Y-%m-%d %H:%M:%S')
		logging.info("process_msg(%s): recorded on=%s",str(msg_num),recordedOnString)
	else:
		logging.info("process_msg(%s): JSON does not contain a timestamp",msg_num)


	GPS=False
	if LATITUDE in parameters.keys() or LONGITUDE in parametsrs.keys():
		logging.info("process_msg(%s): JSON includes GPS lat/long",msg_num)
		GPS=True

	# now update readings table with a timestamp supplied by the device, device_id and raw JSON
	if recordedOnString is not None:
		if GPS:
			sql="INSERT INTO readings (recordedon,device_id,raw_json,reading_latitude,reading_longitude) values (%s,%s,%s,%s,%s)"
			vals = (recordedOnString, device_id, str(payloadJson),str(parameters[LATITUDE]),str(parameters[LONGITUDE]))
		else:
			sql="INSERT INTO readings (recordedon,device_id,raw_json) values (%s,%s,%s)"
			vals = (recordedOnString, device_id, str(payloadJson))
	else:
		if GPS:
			sql="INSERT INTO readings (recordedon,device_id,raw_json,reading_latitude,reading_longitude) values (NULL,%s,%s,%s,%s)"
			vals=(device_id,str(payloadJson),str(parameters[LATITUDE]),str(parameters[LONGITUDE]))
		else:
			sql="INSERT INTO readings (recordedon,device_id,raw_json) values (NULL,%s,%s)"
			vals=(device_id,str(payloadJson))

	readings_id=dbUpdate(sql, vals)

	if readings_id is None:
		logging.error("process_msg(%s) insert record into readings table failed.",msg_num)
		return
	else:
		logging.info("process_msg(%s): readings_id=%s",msg_num,str(readings_id))
		logging.info("process_mag(%s): parameters=%s",msg_num,str(parameters))
		# next insert each parameter's reading into reading_values
		sql = "INSERT INTO reading_values (reading_id, value, reading_value_types_id) VALUES (%s, %s, %s)"
	
		# process the JSON string
		try:
			for key, value in parameters.items():
	
				logging.info("process_msg(%s): trying to add record to reading_values for key=%s",msg_num,str(key))
				if not key in allowed_json_value_keys:
					logging.info("process_msg(%s): Ignoring non-data value key %s found in JSON",msg_num,str(key))
					continue
			
				logging.info("process_msg(%s): processing data value key %s",msg_num,str(key))

				# get the type id from the dictionary
				type_id=types_id[key]
				logging.info("process_msg(%s): got reading_value_types_id %s",msg_num,str(type_id))
			
				# add the new value
				vals=(readings_id,value,type_id)
				id=dbUpdate(sql, vals)
				if id is None:
					logging.error("process_msg(%s): failed to insert new record for %s into reading_values table",msg_num,str(key))
		
				logging.info("process_msg(%s): finished adding data value for key %s",msg_num,str(key))

		except Exception as e:
			logging.exception("process_msg(%s): error adding reading_values",msg_num)
			

		logging.info("process_msg(%s): finished adding to reading_values",msg_num)

	logging.info("process_msg(%s): finished normally",msg_num)



def on_message(mqttc, obj, msg):
	global message_number
	
	msg_num=message_number
	message_number=message_number+1

	logging.info("----------------------------")	# visual separator
	logging.info("on_message(%s) received payload=%s",str(msg_num),msg.payload)
	if not msg.payload.startswith('{') or  not msg.payload.endswith('}'):
		logging.error("on_message(%s): payload is probably not JSON formatted. Ignored.",str(msg_num))
		return;

	process_msg(str(msg_num),msg)

def on_subscribe(mqttc,obj,mid,granted_qos):
	logging.info("on_subscribe(): Subscribed with mid=%s",str(mid))


#############################################################################
#
# main
#
#############################################################################


# open a database connection
try:
	mydb = mysql.connector.connect(
	host=dbHost,
	user=dbUser,
	passwd=dbPassword,
	database=dbName
	)

	logging.info("main(): Opened a database connection ok.")

except Exception as e:
	logging.exception("main(): Unable to connect to the database check settings.py")
	print("main(): Unable to connect to database")
	sys.exit()

# connect to the MQTT broker

try:
	# Start the MQTT loop that runs forever and is blocking.

	logging.info("Trying to connect to the MQTT broker")
	print("Trying to connect to the MQTT broker")

	mqttc=paho.Client()	# uses a random client id
	
	mqttc.on_connect= on_connect
	mqttc.on_subscribe=on_subscribe
	mqttc.on_message=on_message


	if mqttClientUser is not None:
		logging.info("main(): using MQTT authentication")
		mqttc.username_pw_set(username=mqttClientUser,password=mqttClientPassword)
	else:
		logging.info("main(): not using MQTT autentication")

	# terminate if the connection takes too long
	startConnect=time.time()
	mqttc.connect(mqttBroker,keepalive=mqttKeepAlive)


	while not brokerConnected:
		mqttc.loop()
		if (time.time()-startConnect)>mqttConnectTimeout:
			logging.error("main(): broker on_connect time out (%ss)",mqttConnectTimeout)
			print("main(): failed to connect to MQTT broker within timeout. See settings.py")
			sys.exit()
	
	logging.info("main(): Connected to MQTT broker after %s s",int(time.time()-startConnect))
	print("main(): Connected to broker")
	mqttc.loop_forever()

except Exception as e:
	logging.exception("main(): Error connecting to the MQTT broker")
	
	# immediately tell the user
	print("main(): unable to connect to the MQTT broker")
	sys.exit()
